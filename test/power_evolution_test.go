package test

import (
	"math"
	"testing"

	"github.com/filecoin-project/go-f3/gpbft"
	"github.com/filecoin-project/go-f3/sim"
	"github.com/stretchr/testify/require"
)

func TestStoragePower_IncreaseMidSimulation(t *testing.T) {
	const (
		instanceCount                      = 8
		powerIncreaseAfterInstance         = 4
		groupOneStoragePower               = 5
		groupTwoStoragePowerBeforeIncrease = 2
		groupTwoStoragePowerAfterIncrease  = 21
	)
	groupOneStoragePowerer := sim.UniformStoragePower(gpbft.NewStoragePower(groupOneStoragePower))
	groupTwoStoragePowerer := func(instance uint64, id gpbft.ActorID) *gpbft.StoragePower {
		switch {
		case instance < powerIncreaseAfterInstance:
			return gpbft.NewStoragePower(groupTwoStoragePowerBeforeIncrease)
		default:
			return gpbft.NewStoragePower(groupTwoStoragePowerAfterIncrease)
		}
	}

	tests := []struct {
		name    string
		options []sim.Option
	}{
		{
			name:    "sync",
			options: syncOptions(),
		},
		{
			name:    "async",
			options: asyncOptions(t, 55452),
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			repeatInParallel(t, 1, func(t *testing.T, repetition int) {
				seedFuzzer := uint64(repetition)
				tsg := sim.NewTipSetGenerator(7 * seedFuzzer)
				baseChain := generateECChain(t, tsg)
				groupOneEcGenerator := sim.NewUniformECChainGenerator(17*seedFuzzer, 5, 10)
				groupTwoEcGenerator := sim.NewUniformECChainGenerator(23*seedFuzzer, 5, 10)
				sm, err := sim.NewSimulation(
					append(test.options,
						sim.WithBaseChain(&baseChain),
						// Group 1: 10 participants with fixed storage power throughout the simulation
						sim.AddHonestParticipants(
							10,
							groupOneEcGenerator,
							groupOneStoragePowerer),
						// Group 2: 10 participants with smaller storage power up to instance 4 and larger
						// after that.
						sim.AddHonestParticipants(
							10,
							groupTwoEcGenerator,
							groupTwoStoragePowerer),
					)...)
				require.NoError(t, err)
				require.NoErrorf(t, sm.Run(instanceCount, maxRounds), "%s", sm.Describe())

				// Assert that the chains agreed upon belong to group 1 before instance 4 and
				// to group 2 after that.
				base := *baseChain.Head()
				for i := uint64(0); i < instanceCount-1; i++ {
					instance := sm.GetInstance(i + 1)
					require.NotNil(t, instance, "instance %d", i)

					var chainBackedByMostPower, chainBackedByLeastPower gpbft.ECChain
					// UniformECChainGenerator caches the generated chains for each instance and disregards participant IDs.
					if i < powerIncreaseAfterInstance {
						chainBackedByMostPower = groupOneEcGenerator.GenerateECChain(i, base, math.MaxUint64)
						chainBackedByLeastPower = groupTwoEcGenerator.GenerateECChain(i, base, math.MaxUint64)
					} else {
						chainBackedByMostPower = groupTwoEcGenerator.GenerateECChain(i, base, math.MaxUint64)
						chainBackedByLeastPower = groupOneEcGenerator.GenerateECChain(i, base, math.MaxUint64)
					}

					// Sanity check that the chains generated by either group are not the same but
					// share the same base.
					require.Equal(t, chainBackedByMostPower.Base(), chainBackedByLeastPower.Base())
					require.NotEqual(t, chainBackedByMostPower.Suffix(), chainBackedByLeastPower.Suffix())

					// Assert the consensus is reached on the chain with most power.
					requireConsensusAtInstance(t, sm, i, chainBackedByMostPower...)
					base = *instance.BaseChain.Head()
				}
			})
		})
	}
}

func TestStoragePower_DecreaseRevertsToBase(t *testing.T) {
	const (
		instanceCount = 8
	)
	tests := []struct {
		name    string
		options []sim.Option
	}{
		{
			name:    "sync",
			options: syncOptions(),
		},
		{
			name:    "async",
			options: asyncOptions(t, 55452),
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			repeatInParallel(t, 1, func(t *testing.T, repetition int) {
				seedFuzzer := uint64(repetition)
				tsg := sim.NewTipSetGenerator(7 * seedFuzzer)
				baseChain := generateECChain(t, tsg)
				sm, err := sim.NewSimulation(
					append(test.options,
						sim.WithBaseChain(&baseChain),
						// Group 1: 10 participants with fixed storage power of 2 per participant
						// throughout the simulation.
						sim.AddHonestParticipants(
							10,
							sim.NewBaseECChainGenerator(),
							sim.UniformStoragePower(gpbft.NewStoragePower(3)),
						),
						// Group 2: 10 participants with decreasing storage power starting from 8 and
						// decreasing by 1 per instance per participant.
						sim.AddHonestParticipants(
							10,
							sim.NewUniformECChainGenerator(17*seedFuzzer, 5, 10),
							func(instance uint64, id gpbft.ActorID) *gpbft.StoragePower {
								// Decrease storage power of each participant by 1 per instance.
								// The plus one is there to avoid zero powered actors as it is an error.
								return gpbft.NewStoragePower(int64(instanceCount - instance + 1))
							},
						),
					)...)
				require.NoError(t, err)
				require.NoErrorf(t, sm.Run(instanceCount, maxRounds), "%s", sm.Describe())

				// Assert that the last three instances have exactly one tipset in their base
				// chain to which all participants converge. Because, by the fifth instance the
				// total storage power of group 2 should have sufficiently decreased to no longer
				// influence consensus. As a result, the chain proposed by group 1 should become
				// the dominant one and that group always proposes the base chain, which should
				// have exactly one tipset.
				for i := uint64(instanceCount - 3); i < instanceCount; i++ {
					instance := sm.GetInstance(i)
					require.NotNil(t, instance)

					// Assert that the base chain only has one tipset, i.e. the chain proposed by
					// group 1 is the dominant one.
					require.Len(t, instance.BaseChain, 1)

					// Assert that the head tipset of all decisions made by participants is the base
					// of instance's base-chain.
					requireConsensusAtInstance(t, sm, i, *instance.BaseChain.Base())
				}
			})
		})
	}
}
