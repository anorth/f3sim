package sim

import (
	"log"
	"math/rand"

	"github.com/filecoin-project/go-f3/gpbft"
)

// ECChainGenerator generates the ECChain that a simulation participant would
// attempt to reach consensus on at the given GPBFT instance. The return chain
// must have the given TipSet as its base.
type ECChainGenerator interface {
	GenerateECChain(instance uint64, base gpbft.TipSet, id gpbft.ActorID) gpbft.ECChain
}

var _ ECChainGenerator = (*FixedECChainGenerator)(nil)

type FixedECChainGenerator struct {
	chain gpbft.ECChain
}

func NewFixedECChainGenerator(chain gpbft.ECChain) *FixedECChainGenerator {
	return &FixedECChainGenerator{chain: chain}
}

func (f *FixedECChainGenerator) GenerateECChain(uint64, gpbft.TipSet, gpbft.ActorID) gpbft.ECChain {
	return f.chain
}

var _ ECChainGenerator = (*UniformECChainGenerator)(nil)

// UniformECChainGenerator generates deterministic random EC chains that are
// uniform across all participants per instance.
type UniformECChainGenerator struct {
	rng                    *rand.Rand
	tsg                    *TipSetGenerator
	minTipSets, maxTipSets uint64
	chainsByInstance       map[uint64]gpbft.ECChain
}

func NewUniformECChainGenerator(seed, minTipSets, maxTipSets uint64) *UniformECChainGenerator {
	return &UniformECChainGenerator{
		rng:              rand.New(rand.NewSource(int64(seed))),
		tsg:              NewTipSetGenerator(seed),
		minTipSets:       minTipSets,
		maxTipSets:       maxTipSets,
		chainsByInstance: make(map[uint64]gpbft.ECChain),
	}
}

func (u *UniformECChainGenerator) GenerateECChain(instance uint64, base gpbft.TipSet, _ gpbft.ActorID) gpbft.ECChain {
	chain, found := u.chainsByInstance[instance]
	if !found {
		var err error
		chain, err = gpbft.NewChain(base)
		if err != nil {
			log.Panicf("failed to generate ECChain during simulation: %v", err)
		}
		chainLength := generateRandomBetween(u.rng, u.minTipSets, u.maxTipSets)
		for i := uint64(0); i < chainLength; i++ {
			chain = chain.Extend(u.tsg.Sample())
		}
		u.chainsByInstance[instance] = chain
	}
	return chain
}

var _ ECChainGenerator = (*RandomECChainGenerator)(nil)

// RandomECChainGenerator generates deterministic random EC chains with
// configurable min and max number of tpisets per instance per participant.
//
// Note, the generated chains per instance per participant do not change once
// generated.
type RandomECChainGenerator struct {
	rng                           *rand.Rand
	tsg                           *TipSetGenerator
	minTipSets, maxTipSets        uint64
	chainsByInstanceByParticipant map[uint64]map[gpbft.ActorID]gpbft.ECChain
}

func NewRandomECChainGenerator(seed, minTipSets, maxTipSets uint64) *RandomECChainGenerator {
	return &RandomECChainGenerator{
		rng:                           rand.New(rand.NewSource(int64(seed))),
		tsg:                           NewTipSetGenerator(seed),
		minTipSets:                    minTipSets,
		maxTipSets:                    maxTipSets,
		chainsByInstanceByParticipant: make(map[uint64]map[gpbft.ActorID]gpbft.ECChain),
	}
}

func (u *RandomECChainGenerator) GenerateECChain(instance uint64, base gpbft.TipSet, participant gpbft.ActorID) gpbft.ECChain {
	chainsByParticipant, found := u.chainsByInstanceByParticipant[instance]
	if !found {
		chainsByParticipant = make(map[gpbft.ActorID]gpbft.ECChain)
		u.chainsByInstanceByParticipant[instance] = chainsByParticipant
	}
	chain, found := chainsByParticipant[participant]
	if !found {
		var err error
		chain, err = gpbft.NewChain(base)
		if err != nil {
			log.Panicf("failed to generate ECChain during simulation: %v", err)
		}
		chainLength := generateRandomBetween(u.rng, u.minTipSets, u.maxTipSets)
		for i := uint64(0); i < chainLength; i++ {
			chain = chain.Extend(u.tsg.Sample())
		}
		chainsByParticipant[participant] = chain
	}
	return chain
}

func generateRandomBetween(rng *rand.Rand, min, max uint64) uint64 {
	switch {
	case min == max:
		return min
	case min > max:
		return 0
	default:
		return uint64(rng.Int63n(int64(max-min+1))) + min
	}
}

var _ ECChainGenerator = (*AggregateECChainGenerator)(nil)

// AggregateECChainGenerator generates EC chain by aggregating the chains
// generated by a given set of generators in the order their corresponding
// generator is specified.
type AggregateECChainGenerator struct {
	generators []ECChainGenerator
}

func NewAppendingECChainGenerator(g ...ECChainGenerator) *AggregateECChainGenerator {
	return &AggregateECChainGenerator{
		generators: g,
	}
}

func (u *AggregateECChainGenerator) GenerateECChain(instance uint64, base gpbft.TipSet, participant gpbft.ActorID) gpbft.ECChain {
	chain := gpbft.ECChain{base}
	for _, generator := range u.generators {
		chain = chain.Extend(
			generator.GenerateECChain(instance, chain.Head(), participant).
				Suffix()...)
	}
	return chain
}
